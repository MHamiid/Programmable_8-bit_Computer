/* Main.ino file generated by New Project wizard
 *
 * Created:   Mon Jun 13 2022
 * Processor: Arduino Nano
 * Compiler:  Arduino AVR (Proteus)
 */

#define SHIFT_DATA_PIN 2
#define SHIFT_CLK_PIN 3
#define SHIFT_LATCH_PIN 4
/* Data Pins */
#define EEPROM_D0 5
#define EEPROM_D7 12
/**/
#define WRITE_EN 13


 /* 
*   Write the 15-bit address and 1-bit for the EEPROM output enable status
*/
void setEEPROMAddress(int address, bool EEPROMOutputEnable)
{

    // Write the top 7-bits of the address and the output enable status
   shiftOut(SHIFT_DATA_PIN, SHIFT_CLK_PIN, MSBFIRST, ( address >> 8 ) | ( EEPROMOutputEnable ? 0x00 : 0x80 ));    // Shift the 15-bit address 8 places to the right to get the top 7-bits ( MSBs ) of the address and set the output enable status as the (8th bit) top bit
   
   // Write the remaining 8-bit of the address
   shiftOut(SHIFT_DATA_PIN, SHIFT_CLK_PIN, MSBFIRST,  address);              // Passing the full 15-bit address as a parameter ( which is more than a byte ), results in using only the lower 8-bits of the address

   /* 
   *   Output data content to output pins 
   */
   
   // Generate a single High clock pulse
   digitalWrite(SHIFT_LATCH_PIN, LOW);
   digitalWrite(SHIFT_LATCH_PIN, HIGH);
   digitalWrite(SHIFT_LATCH_PIN, LOW);
   
}


/*
* Write a byte to the EEPROM at a specific address 
*/

void writeEEPROM(int address, byte data)
{
   
   setEEPROMAddress(address, false);   // Disable output enable ( we are writing data not reading )

 
   /* Set the data on the data pins */
   // Iterate over the data pins 
   for (int pin = EEPROM_D0; pin <= EEPROM_D7; pin++)
  {
      // Set the data pins to output 
      // NOTE: The order where EEPROM output enable is disabled in setEEPROMAddress() first before setting the pins mode to output
      //, to avoid the EEPROM and arduino writting to the data line at the same time resulting in contention
      pinMode(pin, OUTPUT);
      
      digitalWrite(pin, (data & 1));    // Write the LSB
      data >>= 1;   // Shift the data one bit to the right to position the LSB with corresponding pin
  } 
  
  // Pulse the write enable pin low
  digitalWrite(WRITE_EN, LOW);
  delayMicroseconds(1);      // Delay to match the EERPOM chip min/max time where the write pin is set low
  digitalWrite(WRITE_EN, HIGH);
   delay(5);   // Delay for some time to let the EEPROM compelete the write cycle
}


void setup () {

   // Set pins for output
   pinMode(SHIFT_DATA_PIN, OUTPUT);
   pinMode(SHIFT_CLK_PIN, OUTPUT);
   pinMode(SHIFT_LATCH_PIN, OUTPUT);

   // Initialize the write enable pin to HIGH (Disabled)
   // NOTE: Setting the pin to HIGH before setting the pin mode to OUTPUT, to safely make sure the pin is HIGH, and no data is written
   digitalWrite(WRITE_EN, HIGH);
   pinMode(WRITE_EN, OUTPUT);
   
   Serial.begin(57600);
   
   
   // 4-bit hex decoder for common cathode 7-segment display
   byte sevenSegmentsDigitsCode[] = { 0x7e, 0x30, 0x6d, 0x79, 0x33, 0x5b, 0x5f, 0x70, 0x7f, 0x7b};

   Serial.println("[!] Programming ones place");
   for(int value = 0; value <= 255; value++)
   {
      writeEEPROM(value, sevenSegmentsDigitsCode[value % 10]);                                      // (ones-place)
   }
   
   Serial.println("[!] Programming tens place");
   for(int value = 0; value <= 255; value++)
   {
      writeEEPROM(value + 256, sevenSegmentsDigitsCode[(value / 10) % 10 ]);               // (tens-place)
   }
   
  Serial.println("[!] Programming hundreds place");
  for(int value = 0; value <= 255; value++)
   {
      writeEEPROM(value + 512, sevenSegmentsDigitsCode[value / 100 ]);                        // (hundreds-place)
   }
   
  Serial.println("[!] Programming sign");
  for(int value = 0; value <= 255; value++)
   {
      writeEEPROM(value + 768,0);               									    // Sign
   }
  
  /* For twos complement representation */
  
  Serial.println("[!] Programming ones place for twos complement");
  for(int value = -128; value <= 127; value++)
   {
      writeEEPROM((byte)value + 1024, sevenSegmentsDigitsCode[abs(value) % 10]);                   // (ones-place)
   }
  
   Serial.println("[!] Programming tens place for twos complement");
   for(int value = -128; value <= 127; value++)
   {
      writeEEPROM((byte)value +1280, sevenSegmentsDigitsCode[abs(value / 10) % 10]);           // (tens-place)
   }
  
   Serial.println("[!] Programming hundreds place for twos complement");
   for(int value = -128; value <= 127; value++)
   {
      writeEEPROM((byte)value + 1536, sevenSegmentsDigitsCode[abs(value / 100)]);                // (hundreds-place)
   }
  
   Serial.println("[!] Programming sign for twos complement");
   for(int value = -128; value <= 127; value++)
   {
      byte writeData = 0;    // Positive
      
      if(value < 0)   // Negative
	 writeData = 0x01;    // Outputs (-) on the 7-segments
	 
      writeEEPROM((byte)value + 1792, writeData);                                   			            // Sign
   }
  
   Serial.println("[!] Finished EEPROM programming");
   
   
    /*
     * set the Arduino data pins to input after programming to avoid outputting data to the pins and result in contention with the EEPROM output data
    */
    // Iterate over  the data pins 
   for(int pin = EEPROM_D7; pin >= EEPROM_D0; pin--)
   {
      // Set the pin mode to input
      // NOTE: The order where setting the pins mode to input before EEPROM output is enabled in setEEPROMAddress()
      //, to avoid the EEPROM and arduino writting to the data line at the same time resulting in contention
      pinMode(pin, INPUT);
   }
   
    /*
     *     Enable the EEPROM output bit
    */
   setEEPROMAddress(0, true);
   
}

void loop() {
   
  
}
